<!DOCTYPE html>
<html lang="vi" data-theme="valentine">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Routing - Leaflet Frontend</title>
    
    <!-- Tailwind CSS + DaisyUI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.19/dist/full.min.css" rel="stylesheet" type="text/css" />
    
    <!-- Google Fonts - Inter & Dancing Script -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <!-- Leaflet Sidebar v2 CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-sidebar-v2@3.2.1/css/leaflet-sidebar.css" />
    <!-- Leaflet Control Geocoder CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@1.13.0/dist/Control.Geocoder.css" />
    <!-- Leaflet Contextmenu CSS - Disabled -->
    <!-- Lottie Player -->
    <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
    <!-- Lottie Web (for loading JSON files) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    
    <!-- Tết 2026 Theme CSS -->
    <link rel="stylesheet" href="/static/css/tet-theme.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Typography - Inter for UI, Dancing Script for banner */
        body, .tet-drawer-side {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .tet-header {
            font-family: 'Inter', -apple-system, sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 50%, #FFD700 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.3px;
            filter: drop-shadow(0 2px 4px rgba(255, 215, 0, 0.5));
            position: relative;
            display: inline-block;
        }
        
        .tet-banner {
            font-family: 'Dancing Script', cursive;
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        /* Lottie Animation Containers */
        .lottie-container {
            position: absolute;
            pointer-events: none;
            z-index: 999; /* Same as blossom canvas - below Tet border frame */
        }
        
        .lottie-fireworks {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .lottie-blossom {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .lottie-coin {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
        }
        
        /* Leaflet Sidebar v2 Custom Styling */
        .leaflet-sidebar {
            background: linear-gradient(135deg, var(--glass-bg) 0%, rgba(255, 215, 0, 0.1) 100%);
            backdrop-filter: blur(10px);
            border-right: 2px solid var(--glass-border);
        }
        
        .leaflet-sidebar-tabs > ul > li.active {
            background: var(--tet-red);
        }
        
        .leaflet-sidebar-tabs > ul > li.active > a {
            color: var(--tet-gold);
        }
        
        /* DaisyUI Custom Overrides */
        .input-wrapper {
            position: relative;
        }
        
        .suggestions {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            max-height: 200px;
            overflow-y: auto;
            width: 100%;
            z-index: 1000;
            display: none;
            border-radius: 0 0 0.5rem 0.5rem;
        }
        
        .suggestion-item {
            padding: 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s;
        }
        
        .suggestion-item:hover {
            background: #f0f0f0;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        /* Layer 0: Interactive Map (Base Layer) */
        #map-container {
            height: 100vh;
            position: relative;
            z-index: 1; /* Layer 0: Base layer - lowest priority */
        }
        
        #map {
            width: 100%;
            height: 100%;
            z-index: 1; /* Ensure map stays at base layer */
        }
        
        .leaflet-container {
            z-index: 1 !important; /* Ensure Leaflet map stays at base layer */
        }
        
        /* Stats */
        .stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            font-size: 11px;
            color: #666;
        }
    </style>
</head>
<body>
    <!-- Lottie Animations -->
    <div id="lottie-fireworks" class="lottie-container lottie-fireworks" style="display: none;"></div>
    <div id="lottie-blossom" class="lottie-container lottie-blossom"></div>
    <div id="lottie-coin" class="lottie-container lottie-coin"></div>
    
    <!-- DaisyUI Drawer -->
    <div class="drawer drawer-end">
        <input id="drawer-toggle" type="checkbox" class="drawer-toggle" />
        
        <!-- Drawer Content (Map) -->
        <div class="drawer-content">
            <div id="map-container">
                <!-- Floating Menu Button - Vertical Center Left -->
                <label for="drawer-toggle" class="tet-drawer-toggle-btn" id="drawer-toggle-btn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12h18M3 6h18M3 18h18"/>
                    </svg>
                </label>
                
                <div id="map"></div>
            </div>
        </div>
        
        <!-- Drawer Side (Sidebar) -->
        <div class="drawer-side tet-drawer-side">
            <label for="drawer-toggle" class="drawer-overlay" id="drawer-overlay"></label>
            <div class="menu p-6 w-80 min-h-full tet-sidebar-content">
                <!-- Close Button -->
                <div class="flex justify-end mb-6">
                    <label for="drawer-toggle" class="tet-close-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                    </label>
                </div>
                
                <!-- SF Symbols Style Navigation Icons -->
                <div class="sf-nav-bar mb-6">
                    <button class="sf-nav-icon active" data-tab="home" title="Routing">
                        <!-- arrow.triangle.turn.up.right.diamond -->
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 12h18M12 3v18M7 7l5-5 5 5M17 17l-5 5-5-5"/>
                            <path d="M9 9l3 3-3 3M15 15l-3-3 3-3"/>
                        </svg>
                    </button>
                    <button class="sf-nav-icon" data-tab="flood" title="Flood Zones">
                        <!-- drop.fill -->
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2.69l-8.5 8.5c-1.5 1.5-1.5 3.9 0 5.4s3.9 1.5 5.4 0L12 15.69l3.1 2.9c1.5 1.5 3.9 1.5 5.4 0s1.5-3.9 0-5.4L12 2.69z"/>
                        </svg>
                    </button>
                    <button class="sf-nav-icon" data-tab="block" title="Blocked Roads">
                        <!-- exclamationmark.triangle -->
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 9v4M12 17h.01M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"/>
                        </svg>
                    </button>
                </div>
                
                <!-- Tab Panes -->
                <!-- Home Tab -->
                <div class="tab-pane active" id="tab-home">
                    <h1 class="tet-header mb-6">Vĩnh Tuy Map</h1>
                
                <div class="tet-card mb-4">
                    <div class="tet-card-body">
                        
                        <div class="form-control mb-3">
                            <label class="label">
                                <span class="label-text font-semibold">Điểm bắt đầu</span>
                            </label>
                            <div class="input-wrapper">
                                <input type="text" id="origin" placeholder="Nhập địa chỉ hoặc click map" class="input input-bordered input-primary w-full" />
                                <div class="suggestions" id="originSuggestions"></div>
                            </div>
                        </div>
                        
                        <div class="form-control mb-3">
                            <label class="label">
                                <span class="label-text font-semibold">Điểm kết thúc</span>
                            </label>
                            <div class="input-wrapper">
                                <input type="text" id="destination" placeholder="Nhập địa chỉ hoặc click map" class="input input-bordered input-primary w-full" />
                                <div class="suggestions" id="destinationSuggestions"></div>
                            </div>
                        </div>
                        
                        <div class="form-control mb-3">
                            <label class="label">
                                <span class="label-text font-semibold">Điều kiện thời tiết</span>
                            </label>
                            <select id="weather" class="select select-bordered select-primary w-full">
                                <option value="normal">Bình thường</option>
                                <option value="rain">Mưa</option>
                                <option value="flood">Ngập</option>
                            </select>
                        </div>
                        
                        <button id="findRoute" class="tet-primary-btn w-full">Tìm đường</button>
                        
                        <div id="message" class="mt-3"></div>
                        
                        <div id="routeInfo" class="tet-result-card mt-4" style="display: none;">
                            <h3 class="tet-card-title">Thông tin tuyến đường</h3>
                            <div id="routeInfoContent" class="tet-info-grid"></div>
                        </div>
                    </div>
                </div>
                </div>
                
                <!-- Flood Zones Tab -->
                <div class="tab-pane" id="tab-flood" style="display: none;">
                    <h1 class="tet-header mb-6" data-text="Vùng ngập">Vùng ngập</h1>
                    
                    <div class="tet-card">
                        <div class="tet-card-body">
                            <p class="text-sm text-base-content/70 mb-4">
                                Vẽ polygon hoặc circle trên bản đồ để đánh dấu vùng ngập
                            </p>
                            <div id="floodZonesList"></div>
                            <button id="clearAllFloodZones" class="btn btn-error btn-sm w-full mt-4">
                                Xóa tất cả vùng ngập
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Block Roads Tab -->
                <div class="tab-pane" id="tab-block" style="display: none;">
                    <h1 class="tet-header mb-6" data-text="Cấm đường">Cấm đường</h1>
                    
                    <div class="tet-card">
                        <div class="tet-card-body">
                            <p class="text-sm text-base-content/70 mb-4">
                                Chọn 2 điểm trên bản đồ để cấm đoạn đường giữa 2 điểm đó
                            </p>
                            
                            <button id="toggleMapSelectBlock" class="btn btn-info btn-sm w-full mb-3">
                                Chọn 2 điểm trên bản đồ
                            </button>
                            
                            <div id="mapSelectStatus" class="alert alert-info mb-3" style="display: none;">
                                <span id="mapSelectStatusText"></span>
                                <button id="cancelMapSelect" class="btn btn-xs btn-error ml-2">
                                    Hủy
                                </button>
                            </div>
                            
                            <div id="blockedRoadsList" class="mt-4"></div>
                            <button id="clearAllBlockedRoads" class="btn btn-error btn-sm w-full mt-4">
                                Xóa tất cả đường cấm
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw JS -->
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <!-- Leaflet Sidebar v2 JS -->
    <script src="https://unpkg.com/leaflet-sidebar-v2@3.2.1/js/leaflet-sidebar.js"></script>
    <!-- Leaflet Control Geocoder JS -->
    <script src="https://unpkg.com/leaflet-control-geocoder@1.13.0/dist/Control.Geocoder.js"></script>
    <!-- Leaflet Contextmenu JS - Disabled -->
    <!-- Tết 2026 Theme JS - Load cuối cùng để đảm bảo DOM và Leaflet đã sẵn sàng -->
    <script src="/static/js/tet-theme.js"></script>
    
    <script>
        // API Base URL
        const API_BASE = 'http://localhost:8000/api/v1/routing';
        
        // Map initialization - Phường Vĩnh Tuy, Hà Nội
        const map = L.map('map', {
            contextmenu: false, // Disable context menu
            contextmenuWidth: 0,
            closePopupOnClick: true // Close any popups when clicking map
        }).setView([21.0, 105.875], 14);
        
        // Disable all popups and context menus
        map.options.closePopupOnClick = true;
        
        // Override Leaflet popup to prevent any popup from showing
        const originalOpenPopup = L.Map.prototype.openPopup;
        L.Map.prototype.openPopup = function(popup, latlng, options) {
            // Do nothing - prevent all popups
            return this;
        };
        
        // Prevent right-click context menu on map
        map.getContainer().addEventListener('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        });
        
        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // Initialize Golden Horse Icon for Drawer Toggle Button
        function initGoldenHorseIcon() {
            const iconContainer = document.getElementById('golden-horse-icon');
            if (iconContainer && window.tetThemeInstance && window.tetThemeInstance.getHorseSVG) {
                iconContainer.innerHTML = window.tetThemeInstance.getHorseSVG();
            } else {
                // Fallback if tetThemeInstance not ready
                setTimeout(initGoldenHorseIcon, 100);
            }
        }
        
        // Tab switching logic for SF Symbols Navigation
        function initDrawerTabs() {
            const navIcons = document.querySelectorAll('.sf-nav-icon');
            const tabPanes = document.querySelectorAll('.tab-pane');
            
            navIcons.forEach(icon => {
                icon.addEventListener('click', function() {
                    const targetTab = this.getAttribute('data-tab');
                    
                    // Remove active class from all icons
                    navIcons.forEach(i => i.classList.remove('active'));
                    // Add active class to clicked icon
                    this.classList.add('active');
                    
                    // Hide all tab panes
                    tabPanes.forEach(pane => {
                        pane.style.display = 'none';
                        pane.classList.remove('active');
                    });
                    
                    // Show target tab pane
                    const targetPane = document.getElementById(`tab-${targetTab}`);
                    if (targetPane) {
                        targetPane.style.display = 'block';
                        targetPane.classList.add('active');
                    }
                });
            });
        }
        
        // Click-outside to close drawer
        function initDrawerClickOutside() {
            const drawerToggle = document.getElementById('drawer-toggle');
            const drawerOverlay = document.getElementById('drawer-overlay');
            
            // Close drawer when clicking overlay (but not when popup is open)
            if (drawerOverlay) {
                drawerOverlay.addEventListener('click', function(e) {
                    // Don't close if clicking on a popup
                    if (e.target.closest('.leaflet-popup')) {
                        return;
                    }
                    if (drawerToggle.checked) {
                        drawerToggle.checked = false;
                    }
                });
            }
            
            // When popup opens, disable overlay pointer-events so map clicks work
            map.on('popupopen', function() {
                if (drawerOverlay) {
                    drawerOverlay.style.pointerEvents = 'none';
                }
            });
            
            // When popup closes, re-enable overlay pointer-events if drawer is still open
            map.on('popupclose', function() {
                if (drawerOverlay && drawerToggle.checked) {
                    drawerOverlay.style.pointerEvents = 'auto';
                }
            });
            
            // Close drawer when clicking map (but only if drawer is open and not in special modes)
            // This is handled in the existing map.on('click') handler below
        }
        
        // Initialize drawer functionality
        initDrawerTabs();
        initDrawerClickOutside();
        
        // Initialize Leaflet Control Geocoder (Search Bar)
        const geocoder = L.Control.Geocoder.nominatim({
            geocodingQueryParams: {
                countrycodes: 'vn',
                limit: 5
            }
        });
        
        const geocoderControl = L.Control.geocoder({
            geocoder: geocoder,
            position: 'topright',
            placeholder: 'Tìm kiếm địa chỉ...',
            errorMessage: 'Không tìm thấy kết quả',
            defaultMarkGeocode: false
        }).on('markgeocode', function(e) {
            const latlng = e.geocode.center;
            // Set as origin if origin field is focused, otherwise destination
            if (document.activeElement && document.activeElement.id === 'origin') {
                setOrigin(latlng);
                document.getElementById('origin').value = e.geocode.name;
            } else if (document.activeElement && document.activeElement.id === 'destination') {
                setDestination(latlng);
                document.getElementById('destination').value = e.geocode.name;
            } else {
                // Default: set as origin
                setOrigin(latlng);
                document.getElementById('origin').value = e.geocode.name;
            }
            map.setView(latlng, 15);
        }).addTo(map);
        
        // Disable context menu completely - multiple methods to ensure it's disabled
        if (map.contextmenu) {
            map.contextmenu.disable();
            map.contextmenu.remove();
        }
        
        // Prevent any popup from showing on map click
        map.on('click', function(e) {
            // Close any open popups
            map.closePopup();
        });
        
        // Disable browser context menu on map container
        const mapContainer = map.getContainer();
        mapContainer.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }, true);
        
        // Also prevent on document level for map area
        document.addEventListener('contextmenu', function(e) {
            if (e.target.closest('#map') || e.target.closest('.leaflet-container')) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }, true);
        
        // Initialize Lottie Animations using lottie-player
        function initLottieAnimations() {
            // Fireworks animation (triggered on route calculation)
            const fireworksContainer = document.getElementById('lottie-fireworks');
            if (fireworksContainer) {
                const fireworksPlayer = document.createElement('lottie-player');
                fireworksPlayer.src = '/Components/Fireworks.json';
                fireworksPlayer.background = 'transparent';
                fireworksPlayer.speed = '1';
                fireworksPlayer.style.width = '500px';
                fireworksPlayer.style.height = '500px';
                fireworksPlayer.loop = false;
                fireworksPlayer.autoplay = false;
                fireworksContainer.appendChild(fireworksPlayer);
                window.lottieFireworksPlayer = fireworksPlayer;
            }
            
            // Blossom animation (continuous background)
            const blossomContainer = document.getElementById('lottie-blossom');
            if (blossomContainer) {
                const blossomPlayer = document.createElement('lottie-player');
                blossomPlayer.src = '/Components/Blossom.json';
                blossomPlayer.background = 'transparent';
                blossomPlayer.speed = '0.5';
                blossomPlayer.style.width = '100%';
                blossomPlayer.style.height = '100%';
                blossomPlayer.loop = true;
                blossomPlayer.autoplay = true;
                blossomContainer.appendChild(blossomPlayer);
            }
            
            // Coin animation (decorative)
            const coinContainer = document.getElementById('lottie-coin');
            if (coinContainer) {
                const coinPlayer = document.createElement('lottie-player');
                coinPlayer.src = '/Components/Coin.json';
                coinPlayer.background = 'transparent';
                coinPlayer.speed = '1';
                coinPlayer.style.width = '100px';
                coinPlayer.style.height = '100px';
                coinPlayer.loop = true;
                coinPlayer.autoplay = true;
                coinContainer.appendChild(coinPlayer);
            }
        }
        
        // Initialize Lottie when page loads
        window.addEventListener('load', () => {
            if (typeof LottiePlayer !== 'undefined' || customElements.get('lottie-player')) {
                initLottieAnimations();
            } else {
                // Wait a bit more for lottie-player to load
                setTimeout(initLottieAnimations, 500);
            }
        });
        
        // Variables
        let originMarker = null;
        let destinationMarker = null;
        let routeLayer = null;
        let routeShimmerLayer = null; // Vệt sáng chạy dọc route
        let floodZones = [];
        let blockedRoadSegments = []; // Danh sách các đoạn đường bị cấm
        // floodZoneLabels không cần nữa vì đã lưu trong floodZones
        let drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        
        // Variables cho chọn điểm trên map để cấm đường
        let mapSelectBlockMode = false;
        let mapSelectBlockStep = 0; // 0: chưa chọn, 1: đã chọn điểm đầu, 2: đã chọn điểm cuối
        let mapSelectBlockStart = null;
        let mapSelectBlockEnd = null;
        let mapSelectBlockStartMarker = null;
        let mapSelectBlockEndMarker = null;
        
        // Leaflet Draw - cho phép vẽ polygon và circle (flood zones)
        const drawControl = new L.Control.Draw({
            draw: {
                polygon: {
                    allowIntersection: false,
                    showArea: true
                },
                circle: {
                    showRadius: true,
                    metric: true
                },
                polyline: false,
                rectangle: false,
                circlemarker: false,
                marker: false
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        
        map.addControl(drawControl);
        
        // Disable popups on draw controls
        map.on(L.Draw.Event.CREATED, function(e) {
            // Close any popup that might have been created
            map.closePopup();
        });
        
        map.on(L.Draw.Event.EDITED, function(e) {
            map.closePopup();
        });
        
        map.on(L.Draw.Event.DELETED, function(e) {
            map.closePopup();
        });
        
        // Handle draw events
        map.on(L.Draw.Event.CREATED, function (e) {
            const layer = e.layer;
            drawnItems.addLayer(layer);
            
            // Convert to GeoJSON (giống nhau cho cả Polygon và Circle)
            const geoJson = layer.toGeoJSON();
            
            const zoneNumber = floodZones.length + 1;
            geoJson.properties = {
                blockType: 'flood',
                penalty: 15.0,  // Tăng penalty để route thay đổi rõ ràng
                zoneNumber: zoneNumber
            };
            
            // Lưu thêm radius cho Circle (để backend xử lý)
            if (layer instanceof L.Circle) {
                geoJson.properties.radius = layer.getRadius(); // meters
            }
            
            // Lưu reference đến layer và label
            const label = addFloodZoneLabel(layer, zoneNumber);
            
            floodZones.push({
                geoJson: geoJson,
                layer: layer,
                label: label,
                zoneNumber: zoneNumber
            });
            
            updateFloodZonesList();
            
            // Tự động tìm lại route nếu đã có route trước đó
            if (routeLayer) {
                autoFindRoute();
            }
        });
        
        // Hàm thêm label số cho vùng ngập
        function addFloodZoneLabel(layer, number) {
            let center;
            if (layer instanceof L.Polygon) {
                center = layer.getBounds().getCenter();
            } else if (layer instanceof L.Circle) {
                center = layer.getLatLng();
            } else {
                return null;
            }
            
            const label = L.marker(center, {
                icon: L.divIcon({
                    className: 'flood-zone-label',
                    html: `<div style="
                        background: #ff4444;
                        color: white;
                        border-radius: 50%;
                        width: 30px;
                        height: 30px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 14px;
                        border: 2px solid white;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    ">${number}</div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                }),
                interactive: false,
                zIndexOffset: 1000
            }).addTo(map);
            // Ensure no popup on label
            label.off('click');
            
            return label;
        }
        
        // Cập nhật số trên label
        function updateFloodZoneLabel(label, number) {
            if (label && label._icon) {
                label._icon.innerHTML = `<div style="
                    background: #ff4444;
                    color: white;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                    font-size: 14px;
                    border: 2px solid white;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                ">${number}</div>`;
            }
        }
        
        map.on(L.Draw.Event.DELETED, function (e) {
            const layers = e.layers;
            layers.eachLayer(function (layer) {
                // Tìm và xóa từ floodZones array
                const zoneIndex = floodZones.findIndex(zone => zone.layer === layer);
                if (zoneIndex !== -1) {
                    // Xóa label
                    if (floodZones[zoneIndex].label) {
                        map.removeLayer(floodZones[zoneIndex].label);
                    }
                    // Xóa khỏi array
                    floodZones.splice(zoneIndex, 1);
                }
            });
            
            // Cập nhật lại số thứ tự và label
            updateFloodZoneNumbers();
            updateFloodZonesList();
            
            // Tự động tìm lại route nếu đã có route trước đó (để trả lại trọng số ban đầu)
            if (routeLayer) {
                autoFindRoute();
            }
        });
        
        // Cập nhật lại số thứ tự vùng ngập
        function updateFloodZoneNumbers() {
            floodZones.forEach((zone, index) => {
                const newNumber = index + 1;
                zone.zoneNumber = newNumber;
                zone.geoJson.properties.zoneNumber = newNumber;
                
                // Cập nhật số trên label
                if (zone.label) {
                    updateFloodZoneLabel(zone.label, newNumber);
                }
            });
        }
        
        // Click map to set origin/destination
        let clickMode = null; // 'origin' or 'destination'
        
        document.getElementById('origin').addEventListener('focus', () => {
            clickMode = 'origin';
            map.getContainer().style.cursor = 'crosshair';
        });
        
        document.getElementById('destination').addEventListener('focus', () => {
            clickMode = 'destination';
            map.getContainer().style.cursor = 'crosshair';
        });
        
        document.getElementById('origin').addEventListener('blur', () => {
            if (clickMode === 'origin') {
                clickMode = null;
                map.getContainer().style.cursor = '';
            }
        });
        
        document.getElementById('destination').addEventListener('blur', () => {
            if (clickMode === 'destination') {
                clickMode = null;
                map.getContainer().style.cursor = '';
            }
        });
        
        map.on('click', function(e) {
            // ALWAYS close any popups first - this should work even when drawer is open
            map.closePopup();
            
            // Close drawer if open (but only if not in special interaction modes)
            const drawerToggle = document.getElementById('drawer-toggle');
            if (drawerToggle && drawerToggle.checked && !clickMode && !mapSelectBlockMode) {
                // Only close if clicking on map background (not on markers, popups, etc.)
                const clickedElement = e.originalEvent.target;
                const isMapBackground = clickedElement.classList.contains('leaflet-tile') || 
                                       clickedElement.closest('.leaflet-tile-container') ||
                                       (clickedElement.classList.contains('leaflet-pane') && 
                                        !clickedElement.closest('.leaflet-marker-pane') &&
                                        !clickedElement.closest('.leaflet-popup-pane'));
                
                if (isMapBackground) {
                    drawerToggle.checked = false;
                }
            }
            
            // Xử lý chọn điểm để cấm đường
            if (mapSelectBlockMode) {
                if (mapSelectBlockStep === 0) {
                    // Chọn điểm đầu
                    mapSelectBlockStart = e.latlng;
                    mapSelectBlockStep = 1;
                    
                    // Xóa marker cũ nếu có
                    if (mapSelectBlockStartMarker) {
                        map.removeLayer(mapSelectBlockStartMarker);
                    }
                    
                    // Thêm marker điểm đầu
                    mapSelectBlockStartMarker = L.marker(e.latlng, {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34],
                            shadowSize: [41, 41]
                        })
                    }).addTo(map);
                    // Disable popup
                    mapSelectBlockStartMarker.off('click');
                    mapSelectBlockStartMarker.on('click', function() { map.closePopup(); });
                    
                    document.getElementById('mapSelectStatusText').textContent = 'Đã chọn điểm đầu. Click để chọn điểm cuối.';
                    document.getElementById('mapSelectStatus').style.display = 'block';
                } else if (mapSelectBlockStep === 1) {
                    // Chọn điểm cuối
                    mapSelectBlockEnd = e.latlng;
                    mapSelectBlockStep = 2;
                    
                    // Xóa marker cũ nếu có
                    if (mapSelectBlockEndMarker) {
                        map.removeLayer(mapSelectBlockEndMarker);
                    }
                    
                    // Thêm marker điểm cuối
                    mapSelectBlockEndMarker = L.marker(e.latlng, {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34],
                            shadowSize: [41, 41]
                        })
                    }).addTo(map);
                    // Disable popup
                    mapSelectBlockEndMarker.off('click');
                    mapSelectBlockEndMarker.on('click', function() { map.closePopup(); });
                    
                    // Tự động tìm route và block
                    blockRoadFromMapPoints(mapSelectBlockStart, mapSelectBlockEnd);
                    
                    // Reset
                    resetMapSelectBlockMode();
                }
                return;
            }
            
            // Logic cũ cho origin/destination
            if (clickMode === 'origin') {
                setOrigin(e.latlng);
                document.getElementById('origin').value = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
                document.getElementById('origin').blur();
            } else if (clickMode === 'destination') {
                setDestination(e.latlng);
                document.getElementById('destination').value = `${e.latlng.lat.toFixed(6)}, ${e.latlng.lng.toFixed(6)}`;
                document.getElementById('destination').blur();
            }
        });
        
        function setOrigin(latlng) {
            if (originMarker) {
                originMarker.setLatLng(latlng);
            } else {
                // Use Tết festive marker if available
                let icon;
                if (window.tetThemeInstance && window.tetThemeInstance.createFestiveMarker) {
                    icon = window.tetThemeInstance.createFestiveMarker('start', latlng);
                } else {
                    icon = L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    });
                }
                originMarker = L.marker(latlng, { icon: icon }).addTo(map);
                // Disable popup on marker
                originMarker.off('click');
                originMarker.on('click', function(e) {
                    map.closePopup();
                });
            }
        }
        
        function setDestination(latlng) {
            if (destinationMarker) {
                destinationMarker.setLatLng(latlng);
            } else {
                // Use Tết festive marker if available
                let icon;
                if (window.tetThemeInstance && window.tetThemeInstance.createFestiveMarker) {
                    icon = window.tetThemeInstance.createFestiveMarker('end', latlng);
                } else {
                    icon = L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34],
                        shadowSize: [41, 41]
                    });
                }
                destinationMarker = L.marker(latlng, { icon: icon }).addTo(map);
                // Disable popup on marker
                destinationMarker.off('click');
                destinationMarker.on('click', function(e) {
                    map.closePopup();
                });
            }
        }
        
        // Autocomplete
        let suggestTimeout = null;
        
        function setupAutocomplete(inputId, suggestionsId) {
            const input = document.getElementById(inputId);
            const suggestionsDiv = document.getElementById(suggestionsId);
            
            input.addEventListener('input', function() {
                const query = this.value.trim();
                
                if (query.length < 2) {
                    suggestionsDiv.style.display = 'none';
                    return;
                }
                
                clearTimeout(suggestTimeout);
                suggestTimeout = setTimeout(() => {
                    fetch(`${API_BASE}/suggest?q=${encodeURIComponent(query)}&limit=5`)
                        .then(res => res.json())
                        .then(data => {
                            if (data.results && data.results.length > 0) {
                                suggestionsDiv.innerHTML = '';
                                data.results.forEach(result => {
                                    const item = document.createElement('div');
                                    item.className = 'suggestion-item';
                                    item.textContent = result.address;
                                    item.onclick = () => {
                                        input.value = result.address;
                                        suggestionsDiv.style.display = 'none';
                                        
                                        // Set marker
                                        const latlng = L.latLng(result.lat, result.lon);
                                        if (inputId === 'origin') {
                                            setOrigin(latlng);
                                        } else {
                                            setDestination(latlng);
                                        }
                                    };
                                    suggestionsDiv.appendChild(item);
                                });
                                suggestionsDiv.style.display = 'block';
                            } else {
                                suggestionsDiv.style.display = 'none';
                            }
                        })
                        .catch(err => {
                            console.error('Suggest error:', err);
                            suggestionsDiv.style.display = 'none';
                        });
                }, 300);
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!input.contains(e.target) && !suggestionsDiv.contains(e.target)) {
                    suggestionsDiv.style.display = 'none';
                }
            });
        }
        
        setupAutocomplete('origin', 'originSuggestions');
        setupAutocomplete('destination', 'destinationSuggestions');
        
        // Auto find route (khi thêm/xóa flood zone)
        function autoFindRoute() {
            const origin = document.getElementById('origin').value.trim();
            const destination = document.getElementById('destination').value.trim();
            const weather = document.getElementById('weather').value;
            
            if (!origin || !destination) {
                return; // Không có origin/destination, không tìm route
            }
            
            // Parse input
            let originInput = origin;
            let destinationInput = destination;
            
            // Check if input is coordinates
            const coordRegex = /^(\d+\.?\d*),\s*(\d+\.?\d*)$/;
            const originMatch = origin.match(coordRegex);
            const destMatch = destination.match(coordRegex);
            
            if (originMatch) {
                originInput = [parseFloat(originMatch[1]), parseFloat(originMatch[2])];
            }
            if (destMatch) {
                destinationInput = [parseFloat(destMatch[1]), parseFloat(destMatch[2])];
            }
            
            // Tạo blocking geometries từ blocked road segments (dùng path để block edges)
            const blockingGeometries = blockedRoadSegments.map(segment => ({
                type: "Feature",
                properties: {
                    blockType: "block",
                    path: segment.path  // Gửi path để backend block tất cả edges trong path (không cần geometry)
                },
                geometry: segment.geometry ? {
                    type: "LineString",
                    coordinates: segment.geometry
                } : {
                    type: "Point",
                    coordinates: [0, 0]  // Dummy geometry, backend sẽ dùng path để block edges
                }
            }));
            
            // Prepare request
            const requestBody = {
                origin: originInput,
                destination: destinationInput,
                weather: weather,
                flood_areas: floodZones.map(zone => zone.geoJson),
                blocking_geometries: blockingGeometries
            };
            
            // Call API (silent, không hiển thị message)
            fetch(`${API_BASE}/route`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            })
            .then(res => res.json())
            .then(data => {
                if (!data.error) {
                    displayRoute(data);
                }
            })
            .catch(err => {
                console.error('Auto route error:', err);
            });
        }
        
        // Find route
        document.getElementById('findRoute').addEventListener('click', function() {
            const origin = document.getElementById('origin').value.trim();
            const destination = document.getElementById('destination').value.trim();
            const weather = document.getElementById('weather').value;
            
            if (!origin || !destination) {
                showMessage('Vui lòng nhập điểm bắt đầu và điểm kết thúc', 'error');
                return;
            }
            
            // Parse input
            let originInput = origin;
            let destinationInput = destination;
            
            // Check if input is coordinates
            const coordRegex = /^(\d+\.?\d*),\s*(\d+\.?\d*)$/;
            const originMatch = origin.match(coordRegex);
            const destMatch = destination.match(coordRegex);
            
            if (originMatch) {
                originInput = [parseFloat(originMatch[1]), parseFloat(originMatch[2])];
            }
            if (destMatch) {
                destinationInput = [parseFloat(destMatch[1]), parseFloat(destMatch[2])];
            }
            
            // Tạo blocking geometries từ blocked road segments (dùng path để block edges)
            const blockingGeometries = blockedRoadSegments.map(segment => ({
                type: "Feature",
                properties: {
                    blockType: "block",
                    path: segment.path  // Gửi path để backend block tất cả edges trong path (không cần geometry)
                },
                geometry: segment.geometry ? {
                    type: "LineString",
                    coordinates: segment.geometry
                } : {
                    type: "Point",
                    coordinates: [0, 0]  // Dummy geometry, backend sẽ dùng path để block edges
                }
            }));
            
            // Prepare request
            const requestBody = {
                origin: originInput,
                destination: destinationInput,
                weather: weather,
                flood_areas: floodZones.map(zone => zone.geoJson),
                blocking_geometries: blockingGeometries
            };
            
            // Disable button
            this.disabled = true;
            this.textContent = 'Đang tìm đường...';
            
            // Call API
            fetch(`${API_BASE}/route`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            })
            .then(res => res.json())
            .then(data => {
                this.disabled = false;
                this.textContent = 'Tìm đường';
                
                if (data.error) {
                    showMessage(data.error, 'error');
                    return;
                }
                
                // Display route
                displayRoute(data);
                showMessage('Tìm đường thành công!', 'success');
            })
            .catch(err => {
                this.disabled = false;
                this.textContent = 'Tìm đường';
                showMessage('Lỗi: ' + err.message, 'error');
                console.error('Route error:', err);
            });
        });
        
        function displayRoute(data) {
            // Remove existing route and shimmer
            if (routeLayer) {
                map.removeLayer(routeLayer);
            }
            if (routeShimmerLayer) {
                map.removeLayer(routeShimmerLayer);
                routeShimmerLayer = null;
            }
            if (routeShimmerLayer) {
                map.removeLayer(routeShimmerLayer);
            }
            
            // Draw route
            if (data.route && data.route.geometry && data.route.geometry.coordinates) {
                const coordinates = data.route.geometry.coordinates.map(coord => [coord[1], coord[0]]); // [lat, lng]
                
                // Main route line (base)
                routeLayer = L.polyline(coordinates, {
                    color: '#32CD32', // Lime Green
                    weight: 5,
                    opacity: 0.9
                }).addTo(map);
                
                // Ensure route is on top layer and has proper styling
                routeLayer.bringToFront();
                if (routeLayer._path) {
                    routeLayer._path.style.stroke = '#32CD32'; // Lime Green
                    routeLayer._path.style.strokeWidth = '5px';
                    routeLayer._path.style.opacity = '0.9';
                    routeLayer._path.style.filter = 'drop-shadow(0 2px 4px rgba(50, 205, 50, 0.5))';
                    routeLayer._path.style.zIndex = '1000';
                }
                
                // Create shimmer effect (vệt sáng chạy dọc route)
                routeShimmerLayer = L.polyline(coordinates, {
                    color: '#FFFFFF', // White for shimmer
                    weight: 6,
                    opacity: 0.9
                }).addTo(map);
                
                // Apply shimmer animation to the path
                if (routeShimmerLayer._path) {
                    routeShimmerLayer._path.classList.add('route-shimmer');
                    routeShimmerLayer._path.style.stroke = '#FFFFFF';
                    routeShimmerLayer._path.style.strokeWidth = '6px';
                    routeShimmerLayer._path.style.opacity = '0.9';
                    routeShimmerLayer._path.style.filter = 'drop-shadow(0 0 10px rgba(255, 255, 255, 0.9))';
                    routeShimmerLayer._path.style.zIndex = '1001';
                    routeShimmerLayer._path.style.strokeLinecap = 'round';
                    routeShimmerLayer._path.style.strokeLinejoin = 'round';
                    
                    // Calculate route length from coordinates (fallback if getTotalLength fails)
                    let pathLength = 0;
                    for (let i = 0; i < coordinates.length - 1; i++) {
                        pathLength += map.distance(coordinates[i], coordinates[i + 1]);
                    }
                    
                    // Get SVG path element for animation
                    const svgPath = routeShimmerLayer._path;
                    
                    // Try to get actual path length from SVG
                    let actualPathLength = pathLength;
                    if (svgPath && typeof svgPath.getTotalLength === 'function') {
                        try {
                            actualPathLength = svgPath.getTotalLength();
                        } catch (e) {
                            // Use calculated length as fallback
                            actualPathLength = pathLength;
                        }
                    }
                    
                    // Set up dash array for animation (vệt sáng = 30% độ dài route)
                    const shimmerLength = actualPathLength * 0.3;
                    svgPath.style.strokeDasharray = `${shimmerLength} ${actualPathLength}`;
                    svgPath.style.strokeDashoffset = actualPathLength;
                    
                    // Start animation
                    animateRouteShimmer(svgPath, actualPathLength, shimmerLength);
                }
                
                // Trigger fireworks celebration - Pháo hoa nổ khi tìm được route
                if (window.tetThemeInstance && window.tetThemeInstance.onRouteCalculated) {
                    const bounds = routeLayer.getBounds();
                    const center = bounds.getCenter();
                    // Truyền map instance để convert chính xác tọa độ
                    window.tetThemeInstance.onRouteCalculated(center, map);
                }
                
                // Also trigger Lottie fireworks
                triggerFireworks();
                
                // Fit map to route
                map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
            }
            
            // Display route info with Apple-style grid layout
            const infoContent = document.getElementById('routeInfoContent');
            infoContent.innerHTML = `
                <div class="tet-info-row">
                    <span class="tet-info-label">Khoảng cách</span>
                    <span class="tet-info-value">${(data.distance / 1000).toFixed(2)} km</span>
                </div>
                <div class="tet-info-row">
                    <span class="tet-info-label">Thời gian</span>
                    <span class="tet-info-value">${Math.round(data.duration)} phút</span>
                </div>
                <div class="tet-info-row">
                    <span class="tet-info-label">Số nút</span>
                    <span class="tet-info-value">${data.path ? data.path.length : 0}</span>
                </div>
                ${data.stats ? `
                <div class="tet-info-row">
                    <span class="tet-info-label">Thời gian tìm kiếm</span>
                    <span class="tet-info-value">${data.stats.search_time_ms?.toFixed(2) || 'N/A'} ms</span>
                </div>
                <div class="tet-info-row">
                    <span class="tet-info-label">Đường bị ảnh hưởng</span>
                    <span class="tet-info-value">${data.stats.affected_edges || 0}</span>
                </div>
                ` : ''}
            `;
            
            document.getElementById('routeInfo').style.display = 'block';
        }
        
        // Animate shimmer effect along route
        function animateRouteShimmer(pathElement, pathLength, shimmerLength) {
            // Animation: vệt sáng chạy từ đầu đến cuối, lặp lại liên tục
            let startTime = null;
            const duration = 3000; // 3 seconds per loop
            
            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = (elapsed % duration) / duration; // Loop from 0 to 1
                
                // Calculate stroke-dashoffset: vệt sáng chạy từ đầu (pathLength) đến cuối (-shimmerLength)
                // Khi progress = 0: offset = pathLength (vệt ở đầu)
                // Khi progress = 1: offset = -shimmerLength (vệt đã chạy hết)
                const offset = pathLength - (progress * (pathLength + shimmerLength));
                pathElement.style.strokeDashoffset = offset;
                
                // Continue animation loop
                requestAnimationFrame(animate);
            }
            
            // Start animation
            requestAnimationFrame(animate);
        }
        
        function showMessage(message, type) {
            const messageDiv = document.getElementById('message');
            // Use DaisyUI alert classes
            const alertType = type === 'error' ? 'alert-error' : type === 'success' ? 'alert-success' : 'alert-info';
            messageDiv.innerHTML = `
                <div class="alert ${alertType}">
                    <span>${message}</span>
                </div>
            `;
            messageDiv.style.display = 'block';
            
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 5000);
        }
        
        // Trigger fireworks animation on route calculation
        function triggerFireworks() {
            if (window.lottieFireworksPlayer) {
                const fireworksContainer = document.getElementById('lottie-fireworks');
                fireworksContainer.style.display = 'block';
                window.lottieFireworksPlayer.play();
                window.lottieFireworksPlayer.addEventListener('complete', function() {
                    fireworksContainer.style.display = 'none';
                }, { once: true });
            }
        }
        
        function updateFloodZonesList() {
            const listDiv = document.getElementById('floodZonesList');
            listDiv.innerHTML = '';
            
            if (floodZones.length === 0) {
                listDiv.innerHTML = '<p style="font-size: 12px; color: #999;">Chưa có vùng ngập nào</p>';
                return;
            }
            
            floodZones.forEach((zone, index) => {
                const item = document.createElement('div');
                item.className = 'flood-zone-item';
                item.innerHTML = `
                    <span>Vùng ngập #${index + 1}</span>
                    <button onclick="removeFloodZone(${index})">Xóa</button>
                `;
                listDiv.appendChild(item);
            });
        }
        
        function removeFloodZone(index) {
            if (index < 0 || index >= floodZones.length) {
                return;
            }
            
            const zone = floodZones[index];
            
            // Xóa layer khỏi map
            if (zone.layer) {
                drawnItems.removeLayer(zone.layer);
            }
            
            // Xóa label khỏi map
            if (zone.label) {
                map.removeLayer(zone.label);
            }
            
            // Xóa khỏi array
            floodZones.splice(index, 1);
            
            // Cập nhật lại số thứ tự cho các vùng còn lại
            updateFloodZoneNumbers();
            updateFloodZonesList();
            
            // Tự động tìm lại route để trả lại trọng số ban đầu
            if (routeLayer) {
                autoFindRoute();
            }
        }
        
        // Toggle chế độ chọn điểm trên map để cấm đường
        document.getElementById('toggleMapSelectBlock').addEventListener('click', function() {
            if (mapSelectBlockMode) {
                resetMapSelectBlockMode();
                this.textContent = 'Chọn 2 điểm trên bản đồ';
                this.style.background = '#FFD700'; // Golden yellow
            } else {
                mapSelectBlockMode = true;
                mapSelectBlockStep = 0;
                this.textContent = 'Đang chọn điểm... (Click để hủy)';
                this.style.background = '#ff9800';
                document.getElementById('mapSelectStatus').style.display = 'block';
                document.getElementById('mapSelectStatusText').textContent = 'Click trên bản đồ để chọn điểm đầu.';
                map.getContainer().style.cursor = 'crosshair';
            }
        });
        
        // Hủy chọn điểm trên map
        document.getElementById('cancelMapSelect').addEventListener('click', function() {
            resetMapSelectBlockMode();
            document.getElementById('toggleMapSelectBlock').textContent = 'Chọn 2 điểm trên bản đồ';
            document.getElementById('toggleMapSelectBlock').style.background = '#FFD700'; // Golden yellow
        });
        
        // Reset chế độ chọn điểm trên map
        function resetMapSelectBlockMode() {
            mapSelectBlockMode = false;
            mapSelectBlockStep = 0;
            mapSelectBlockStart = null;
            mapSelectBlockEnd = null;
            
            if (mapSelectBlockStartMarker) {
                map.removeLayer(mapSelectBlockStartMarker);
                mapSelectBlockStartMarker = null;
            }
            if (mapSelectBlockEndMarker) {
                map.removeLayer(mapSelectBlockEndMarker);
                mapSelectBlockEndMarker = null;
            }
            
            document.getElementById('mapSelectStatus').style.display = 'none';
            map.getContainer().style.cursor = '';
        }
        
        // Block đường từ 2 điểm trên map
        function blockRoadFromMapPoints(startLatLng, endLatLng) {
            // Gọi route API với tọa độ
            fetch(`${API_BASE}/route`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    origin: [startLatLng.lat, startLatLng.lng],
                    destination: [endLatLng.lat, endLatLng.lng],
                    weather: 'normal',
                    flood_areas: [],
                    blocking_geometries: []
                })
            })
            .then(res => res.json())
            .then(data => {
                if (data.error) {
                    showMessage('Không tìm được đường: ' + data.error, 'error');
                    return;
                }
                
                if (!data.path || data.path.length < 2) {
                    showMessage('Không tìm được đường giữa 2 điểm', 'error');
                    return;
                }
                
                // Thêm vào danh sách blocked (có geometry từ route response)
                const geometry = data.route && data.route.geometry ? data.route.geometry.coordinates : null;
                addBlockedRoadSegmentFromPath(data.path, geometry, startLatLng, endLatLng);
            })
            .catch(err => {
                showMessage('Lỗi: ' + err.message, 'error');
                console.error('Block road from map points error:', err);
            });
        }
        
        
        // Thêm đoạn đường cấm từ path (có geometry từ route response)
        function addBlockedRoadSegmentFromPath(path, geometry, startLatLng, endLatLng) {
            let redLine;
            
            if (geometry && geometry.length > 0) {
                // Vẽ đường màu đỏ từ geometry (chính xác)
                const coordinates = geometry.map(coord => [coord[1], coord[0]]); // [lat, lng]
                redLine = L.polyline(coordinates, {
                    color: '#ff0000',
                    weight: 5,
                    opacity: 0.8
                }).addTo(map);
            } else {
                // Fallback: vẽ đường thẳng từ start đến end
                redLine = L.polyline([[startLatLng.lat, startLatLng.lng], [endLatLng.lat, endLatLng.lng]], {
                    color: '#ff0000',
                    weight: 5,
                    opacity: 0.8
                }).addTo(map);
            }
            
            // Lưu vào danh sách (chỉ có path, không cần geometry đầy đủ - backend sẽ dùng path)
            blockedRoadSegments.push({
                path: path,
                layer: redLine,
                startName: `${startLatLng.lat.toFixed(4)}, ${startLatLng.lng.toFixed(4)}`,
                endName: `${endLatLng.lat.toFixed(4)}, ${endLatLng.lng.toFixed(4)}`
            });
            
            updateBlockedRoadsList();
            
            // Tự động tìm lại route nếu đã có route trước đó
            if (routeLayer) {
                autoFindRoute();
            }
        }
        
        // Cập nhật danh sách blocked roads
        function updateBlockedRoadsList() {
            const listDiv = document.getElementById('blockedRoadsList');
            listDiv.innerHTML = '';
            
            if (blockedRoadSegments.length === 0) {
                listDiv.innerHTML = '<p style="font-size: 12px; color: #999;">Chưa có đường nào bị cấm</p>';
                return;
            }
            
            blockedRoadSegments.forEach((segment, index) => {
                const item = document.createElement('div');
                item.className = 'flood-zone-item';
                item.innerHTML = `
                    <span>${segment.startName} → ${segment.endName}</span>
                    <button onclick="removeBlockedRoad(${index})">Xóa</button>
                `;
                listDiv.appendChild(item);
            });
        }
        
        // Xóa blocked road
        function removeBlockedRoad(index) {
            const segment = blockedRoadSegments[index];
            
            // Xóa layer khỏi map
            map.removeLayer(segment.layer);
            
            // Xóa khỏi danh sách
            blockedRoadSegments.splice(index, 1);
            updateBlockedRoadsList();
            
            // Tự động tìm lại route để trả lại trọng số ban đầu
            if (routeLayer) {
                autoFindRoute();
            }
        }
        
        // Xóa tất cả flood zones
        document.getElementById('clearAllFloodZones').addEventListener('click', function() {
            // Xóa tất cả layers và labels
            floodZones.forEach(zone => {
                if (zone.layer) {
                    drawnItems.removeLayer(zone.layer);
                }
                if (zone.label) {
                    map.removeLayer(zone.label);
                }
            });
            
            // Xóa array
            floodZones = [];
            updateFloodZonesList();
            
            // Tự động tìm lại route để reset trọng số
            if (routeLayer) {
                autoFindRoute();
            }
            
            showMessage('Đã xóa tất cả vùng ngập', 'success');
        });
        
        // Xóa tất cả blocked roads
        document.getElementById('clearAllBlockedRoads').addEventListener('click', function() {
            // Xóa tất cả layers khỏi map
            blockedRoadSegments.forEach(segment => {
                map.removeLayer(segment.layer);
            });
            
            blockedRoadSegments = [];
            updateBlockedRoadsList();
            
            // Tự động tìm lại route để reset trọng số
            if (routeLayer) {
                autoFindRoute();
            }
            
            showMessage('Đã xóa tất cả đường cấm', 'success');
        });
        
        // Cập nhật autoFindRoute để bao gồm blocked roads
        const originalAutoFindRoute = autoFindRoute;
        autoFindRoute = function() {
            const origin = document.getElementById('origin').value.trim();
            const destination = document.getElementById('destination').value.trim();
            const weather = document.getElementById('weather').value;
            
            if (!origin || !destination) {
                return;
            }
            
            let originInput = origin;
            let destinationInput = destination;
            
            const coordRegex = /^(\d+\.?\d*),\s*(\d+\.?\d*)$/;
            const originMatch = origin.match(coordRegex);
            const destMatch = destination.match(coordRegex);
            
            if (originMatch) {
                originInput = [parseFloat(originMatch[1]), parseFloat(originMatch[2])];
            }
            if (destMatch) {
                destinationInput = [parseFloat(destMatch[1]), parseFloat(destMatch[2])];
            }
            
            // Tạo blocking geometries từ blocked road segments (dùng path để block edges)
            const blockingGeometries = blockedRoadSegments.map(segment => ({
                type: "Feature",
                properties: {
                    blockType: "block",
                    path: segment.path  // Gửi path để backend block tất cả edges trong path (không cần geometry)
                },
                geometry: segment.geometry ? {
                    type: "LineString",
                    coordinates: segment.geometry
                } : {
                    type: "Point",
                    coordinates: [0, 0]  // Dummy geometry, backend sẽ dùng path để block edges
                }
            }));
            
            const requestBody = {
                origin: originInput,
                destination: destinationInput,
                weather: weather,
                flood_areas: floodZones.map(zone => zone.geoJson),
                blocking_geometries: blockingGeometries
            };
            
            fetch(`${API_BASE}/route`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            })
            .then(res => res.json())
            .then(data => {
                if (!data.error) {
                    displayRoute(data);
                }
            })
            .catch(err => {
                console.error('Auto route error:', err);
            });
        };
        
        // Cập nhật findRoute để bao gồm blocked roads
        const originalFindRouteHandler = document.getElementById('findRoute').onclick;
        document.getElementById('findRoute').addEventListener('click', function() {
            const origin = document.getElementById('origin').value.trim();
            const destination = document.getElementById('destination').value.trim();
            const weather = document.getElementById('weather').value;
            
            if (!origin || !destination) {
                showMessage('Vui lòng nhập điểm bắt đầu và điểm kết thúc', 'error');
                return;
            }
            
            let originInput = origin;
            let destinationInput = destination;
            
            const coordRegex = /^(\d+\.?\d*),\s*(\d+\.?\d*)$/;
            const originMatch = origin.match(coordRegex);
            const destMatch = destination.match(coordRegex);
            
            if (originMatch) {
                originInput = [parseFloat(originMatch[1]), parseFloat(originMatch[2])];
            }
            if (destMatch) {
                destinationInput = [parseFloat(destMatch[1]), parseFloat(destMatch[2])];
            }
            
            // Tạo blocking geometries từ blocked road segments (dùng path để block edges)
            const blockingGeometries = blockedRoadSegments.map(segment => ({
                type: "Feature",
                properties: {
                    blockType: "block",
                    path: segment.path  // Gửi path để backend block tất cả edges trong path (không cần geometry)
                },
                geometry: segment.geometry ? {
                    type: "LineString",
                    coordinates: segment.geometry
                } : {
                    type: "Point",
                    coordinates: [0, 0]  // Dummy geometry, backend sẽ dùng path để block edges
                }
            }));
            
            const requestBody = {
                origin: originInput,
                destination: destinationInput,
                weather: weather,
                flood_areas: floodZones.map(zone => zone.geoJson),
                blocking_geometries: blockingGeometries
            };
            
            this.disabled = true;
            this.textContent = 'Đang tìm đường...';
            
            fetch(`${API_BASE}/route`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            })
            .then(res => res.json())
            .then(data => {
                this.disabled = false;
                this.textContent = 'Tìm đường';
                
                if (data.error) {
                    showMessage(data.error, 'error');
                    return;
                }
                
                displayRoute(data);
                showMessage('Tìm đường thành công!', 'success');
            })
            .catch(err => {
                this.disabled = false;
                this.textContent = 'Tìm đường';
                showMessage('Lỗi: ' + err.message, 'error');
                console.error('Route error:', err);
            });
        });
        
        // Initialize
        updateFloodZonesList();
        updateBlockedRoadsList();
        
        // Initialize Tết Theme - Đảm bảo chạy sau khi Leaflet và DOM đã sẵn sàng
        // TetTheme sẽ tự động khởi tạo khi script load, nhưng đảm bảo instance được lưu
        if (typeof TetTheme !== 'undefined' && !window.tetThemeInstance) {
            window.tetThemeInstance = new TetTheme();
        }
    </script>
</body>
</html>

